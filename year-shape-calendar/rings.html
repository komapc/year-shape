<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multi-Ring Calendar - YearWheel</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        color: white;
      }

      h1 {
        margin-bottom: 10px;
        font-size: 2rem;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        margin-bottom: 20px;
        opacity: 0.9;
        font-size: 0.9rem;
      }

      .controls {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        width: 600px;
        max-width: 90vw;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        font-size: 0.9rem;
      }

      input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: white;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        border: none;
      }

      .value-display {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        padding: 3px 10px;
        border-radius: 5px;
        font-weight: 600;
        font-size: 0.85rem;
        margin-left: 10px;
      }

      .main-content {
        display: flex;
        gap: 20px;
        align-items: flex-start;
        max-width: 1200px;
      }

      #canvas-container {
        position: relative;
        width: 700px;
        height: 700px;
        max-width: 90vw;
        max-height: 90vw;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        flex-shrink: 0;
      }

      .layer-controls {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        min-width: 250px;
        max-width: 300px;
      }

      .layer-controls h3 {
        margin: 0 0 15px 0;
        font-size: 1.1rem;
        font-weight: 600;
      }

      .layer-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .layer-item {
        background: rgba(255, 255, 255, 0.15);
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 8px;
        cursor: move;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .layer-item:hover {
        background: rgba(255, 255, 255, 0.25);
        transform: translateX(5px);
      }

      .layer-item.dragging {
        opacity: 0.5;
        transform: rotate(2deg);
      }

      .layer-item.drag-over {
        border-top: 3px solid white;
      }

      .drag-handle {
        font-size: 1.2rem;
        cursor: grab;
        user-select: none;
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .layer-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .layer-name {
        flex: 1;
        font-weight: 500;
        font-size: 0.9rem;
      }

      .layer-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 2px solid rgba(255, 255, 255, 0.5);
      }

      svg {
        width: 100%;
        height: 100%;
      }

      .ring-sector {
        stroke: rgba(255, 255, 255, 0.6);
        stroke-width: 1.5;
        cursor: pointer;
        transition: opacity 0.2s, stroke-width 0.2s;
      }

      .ring-sector:hover {
        opacity: 0.9;
        stroke: white;
        stroke-width: 3;
      }

      .ring-separator {
        fill: none;
        stroke: rgba(0, 0, 0, 0.25);
        stroke-width: 3;
        pointer-events: none;
      }

      .ring-label {
        fill: rgba(0, 0, 0, 0.9);
        font-size: 13px;
        font-weight: 700;
        pointer-events: none;
        user-select: none;
        paint-order: stroke fill;
        stroke: rgba(255, 255, 255, 0.8);
        stroke-width: 3px;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .center-text {
        fill: rgba(0, 0, 0, 0.7);
        font-size: 32px;
        font-weight: 700;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }

      .info-panel {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        font-size: 0.85rem;
        max-width: 250px;
        line-height: 1.6;
      }

      .info-panel h3 {
        margin-bottom: 8px;
        font-size: 1rem;
      }

      .info-panel p {
        margin: 4px 0;
        opacity: 0.9;
      }
    </style>
  </head>
  <body>
    <h1>ðŸŽ¯ Multi-Ring Calendar</h1>
    <p class="subtitle">
      Perimeter-preserving morphing shape with 5 calendar rings + drag-and-drop
      reordering
    </p>

    <div class="controls">
      <div class="control-group">
        <label>
          Shape (Square â†” Circle)
          <span class="value-display" id="cornerValue">50%</span>
        </label>
        <input type="range" id="cornerRadius" min="0" max="100" value="50" />
      </div>

      <div class="control-group">
        <label>
          Ring Width
          <span class="value-display" id="widthValue">50px</span>
        </label>
        <input type="range" id="ringWidth" min="30" max="80" value="50" />
      </div>

      <div class="control-group">
        <label>Direction & Rotation</label>
        <div style="display: flex; gap: 10px; margin-top: 8px">
          <button
            id="directionToggle"
            style="
              flex: 1;
              padding: 8px;
              background: rgba(255, 255, 255, 0.2);
              border: 1px solid rgba(255, 255, 255, 0.3);
              border-radius: 6px;
              color: white;
              cursor: pointer;
              font-weight: 600;
              transition: all 0.2s;
            "
          >
            â†» CW
          </button>
          <button
            id="rotateYear"
            style="
              flex: 1;
              padding: 8px;
              background: rgba(255, 255, 255, 0.2);
              border: 1px solid rgba(255, 255, 255, 0.3);
              border-radius: 6px;
              color: white;
              cursor: pointer;
              font-weight: 600;
              transition: all 0.2s;
            "
          >
            ðŸ”„ Rotate 90Â°
          </button>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div id="canvas-container">
        <svg id="calendar-svg" viewBox="0 0 700 700">
          <defs>
            <!-- Gradients for each ring -->
            <linearGradient
              id="gradient-seasons"
              x1="0%"
              y1="0%"
              x2="100%"
              y2="100%"
            >
              <stop offset="0%" style="stop-color: #667eea; stop-opacity: 1" />
              <stop
                offset="100%"
                style="stop-color: #764ba2; stop-opacity: 1"
              />
            </linearGradient>
            <linearGradient
              id="gradient-months"
              x1="0%"
              y1="0%"
              x2="100%"
              y2="100%"
            >
              <stop offset="0%" style="stop-color: #f093fb; stop-opacity: 1" />
              <stop
                offset="100%"
                style="stop-color: #f5576c; stop-opacity: 1"
              />
            </linearGradient>
            <linearGradient
              id="gradient-hebrew"
              x1="0%"
              y1="0%"
              x2="100%"
              y2="100%"
            >
              <stop offset="0%" style="stop-color: #4facfe; stop-opacity: 1" />
              <stop
                offset="100%"
                style="stop-color: #00f2fe; stop-opacity: 1"
              />
            </linearGradient>
            <linearGradient
              id="gradient-weeks"
              x1="0%"
              y1="0%"
              x2="100%"
              y2="100%"
            >
              <stop offset="0%" style="stop-color: #43e97b; stop-opacity: 1" />
              <stop
                offset="100%"
                style="stop-color: #38f9d7; stop-opacity: 1"
              />
            </linearGradient>
            <linearGradient
              id="gradient-holidays"
              x1="0%"
              y1="0%"
              x2="100%"
              y2="100%"
            >
              <stop offset="0%" style="stop-color: #ffeaa7; stop-opacity: 1" />
              <stop
                offset="100%"
                style="stop-color: #fdcb6e; stop-opacity: 1"
              />
            </linearGradient>
          </defs>

          <!-- Ring groups (rendered by JavaScript) -->
          <g id="rings-container"></g>

          <!-- Today indicator line -->
          <line
            id="todayLine"
            x1="350"
            y1="350"
            x2="350"
            y2="100"
            stroke="#ff4444"
            stroke-width="3"
            stroke-dasharray="5,5"
            opacity="0.8"
            pointer-events="none"
          >
            <animate
              attributeName="opacity"
              values="0.8;1;0.8"
              dur="2s"
              repeatCount="indefinite"
            />
          </line>

          <!-- Today indicator dot at the end of line -->
          <circle
            id="todayDot"
            cx="350"
            cy="100"
            r="6"
            fill="#ff4444"
            stroke="white"
            stroke-width="2"
            pointer-events="none"
          >
            <animate
              attributeName="r"
              values="6;8;6"
              dur="2s"
              repeatCount="indefinite"
            />
          </circle>

          <!-- Center text (will be counter-mirrored by JavaScript in CCW mode) -->
          <text
            class="center-text"
            id="centerText"
            x="350"
            y="350"
            transform-origin="350 350"
          >
            2025
          </text>
        </svg>
      </div>

      <div class="layer-controls">
        <h3>ðŸ“š Layer Controls</h3>
        <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 15px">
          Drag to reorder â€¢ Click checkbox to show/hide
        </p>
        <ul class="layer-list" id="layerList">
          <!-- Populated by JavaScript -->
        </ul>
      </div>
    </div>

    <div class="info-panel">
      <h3>ðŸ“Š Current State</h3>
      <p><strong>Perimeter:</strong> <span id="perimeterInfo">â€”</span></p>
      <p><strong>Base Radius:</strong> <span id="radiusInfo">â€”</span></p>
      <p><strong>Corner Radius:</strong> <span id="cornerInfo">â€”</span></p>
      <p style="margin-top: 10px; opacity: 0.7; font-size: 0.75rem">
        ðŸ’¡ Perimeter stays constant as shape morphs
      </p>
    </div>

    <script>
      // ============================================
      // ABSTRACT BASE CLASS
      // ============================================

      class Ring {
        constructor(name, gradientId) {
          this.name = name;
          this.gradientId = gradientId;
          this.innerRadius = 0;
          this.outerRadius = 0;
          this.cornerRadius = 0;
          this.centerX = 0;
          this.centerY = 0;
          this.svgGroup = null;
        }

        // Abstract methods (to be implemented by subclasses)
        get sectorCount() {
          throw new Error("Must implement sectorCount getter");
        }

        getSectorLabel(index) {
          throw new Error("Must implement getSectorLabel");
        }

        getSectorColor(index) {
          return `url(#${this.gradientId})`;
        }

        // Concrete methods (shared implementation)

        render(container) {
          // Create SVG group for this ring
          this.svgGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          this.svgGroup.setAttribute("class", `ring ring-${this.name}`);
          container.appendChild(this.svgGroup);
        }

        layout(
          centerX,
          centerY,
          innerRadius,
          outerRadius,
          cornerRadius,
          direction = 1,
          rotationOffset = 0
        ) {
          this.centerX = centerX;
          this.centerY = centerY;
          this.innerRadius = innerRadius;
          this.outerRadius = outerRadius;
          this.cornerRadius = cornerRadius;
          this.direction = direction; // Store for label drawing

          // Clear previous content
          this.svgGroup.innerHTML = "";

          // Draw all sectors
          const anglePerSector = (Math.PI * 2) / this.sectorCount;
          // Offset so first sector is centered at top (12 o'clock)
          const baseOffset = -Math.PI / 2 - anglePerSector / 2;
          const rotationRad = (rotationOffset * Math.PI) / 180;
          const startOffset = baseOffset + rotationRad;

          for (let i = 0; i < this.sectorCount; i++) {
            const startAngle = startOffset + i * anglePerSector;
            const endAngle = startAngle + anglePerSector;
            
            // For CCW, mirror angles around vertical axis: Î¸ â†’ Ï€ - Î¸
            const mirroredStart = this.direction === -1 ? (Math.PI - startAngle) : startAngle;
            const mirroredEnd = this.direction === -1 ? (Math.PI - endAngle) : endAngle;
            
            this.drawSector(i, mirroredStart, mirroredEnd);
          }

          // Draw separator line (outer edge of ring)
          this.drawSeparator();
        }

        drawSector(index, startAngle, endAngle) {
          const path = this.createSectorPath(startAngle, endAngle);
          const pathElement = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          pathElement.setAttribute("d", path);
          pathElement.setAttribute("fill", this.getSectorColor(index));
          pathElement.setAttribute("class", "ring-sector");
          pathElement.setAttribute("data-sector", index);

          // Add click handler
          pathElement.addEventListener("click", () => {
            console.log(
              `${this.name} - Sector ${index}: ${this.getSectorLabel(index)}`
            );
            alert(`${this.name}\nSector: ${this.getSectorLabel(index)}`);
          });

          this.svgGroup.appendChild(pathElement);

          // Draw label
          this.drawLabel(index, (startAngle + endAngle) / 2);
        }

        createSectorPath(startAngle, endAngle) {
          // Create path for a sector (wedge) with rounded corners
          const outerStart = this.getPointOnShape(startAngle, this.outerRadius);
          const outerEnd = this.getPointOnShape(endAngle, this.outerRadius);
          const innerStart = this.getPointOnShape(startAngle, this.innerRadius);
          const innerEnd = this.getPointOnShape(endAngle, this.innerRadius);

          // Build SVG path
          const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;

          return `
          M ${outerStart.x} ${outerStart.y}
          A ${this.outerRadius} ${this.outerRadius} 0 ${largeArc} 1 ${outerEnd.x} ${outerEnd.y}
          L ${innerEnd.x} ${innerEnd.y}
          A ${this.innerRadius} ${this.innerRadius} 0 ${largeArc} 0 ${innerStart.x} ${innerStart.y}
          Z
        `.trim();
        }

         getPointOnShape(angle, radius) {
           // Calculate point on shape (interpolated between circle and square)
           const t = this.cornerRadius;

            // Pure circle coordinates
            const circleX = this.centerX + radius * Math.cos(angle);
            const circleY = this.centerY + radius * Math.sin(angle);

          // Pure square coordinates (inscribed in circle)
          const absAngle = Math.abs(angle % (Math.PI * 2));
          const normalizedAngle = angle % (Math.PI * 2);

          // Determine which side of the square we're on
          let squareX, squareY;
          const tan = Math.tan(normalizedAngle);
          const squareRadius = radius / Math.sqrt(2); // Half diagonal

          if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
            // Closer to left or right side
            squareX = this.centerX + Math.sign(Math.cos(angle)) * squareRadius;
            squareY =
              this.centerY + Math.sign(Math.cos(angle)) * squareRadius * tan;
          } else {
            // Closer to top or bottom side
            squareX =
              this.centerX + (Math.sign(Math.sin(angle)) * squareRadius) / tan;
            squareY = this.centerY + Math.sign(Math.sin(angle)) * squareRadius;
          }

          // Linear interpolation between circle and square
          const x = circleX * t + squareX * (1 - t);
          const y = circleY * t + squareY * (1 - t);

          return { x, y };
        }

        drawLabel(index, angle) {
          const label = this.getSectorLabel(index);
          if (!label) return;

          const midRadius = (this.innerRadius + this.outerRadius) / 2;
          const point = this.getPointOnShape(angle, midRadius);

          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", point.x);
          text.setAttribute("y", point.y);
          text.setAttribute("class", "ring-label");
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");

          // For CCW mode, mirror the angle for text rotation
          const mirroredAngle = this.direction === -1 ? Math.PI - angle : angle;

          // Rotate text to follow curve - always keep readable
          // Normalize angle to 0-360 range
          let normalizedAngle = ((mirroredAngle * 180) / Math.PI) % 360;
          if (normalizedAngle < 0) normalizedAngle += 360;

          // Base rotation perpendicular to radius
          let rotation = normalizedAngle + 90;

          // Flip text if it would be upside down (reading from outside)
          if (rotation > 90 && rotation < 270) {
            rotation += 180;
          }

          text.setAttribute(
            "transform",
            `rotate(${rotation}, ${point.x}, ${point.y})`
          );
          text.textContent = label;

          this.svgGroup.appendChild(text);
        }

        drawSeparator() {
          // Draw a circular/square line at the outer edge
          const path = this.createShapePath(this.outerRadius);
          const pathElement = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          pathElement.setAttribute("d", path);
          pathElement.setAttribute("class", "ring-separator");
          this.svgGroup.appendChild(pathElement);
        }

        createShapePath(radius) {
          const points = [];
          const segments = 360;

          for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;
            const point = this.getPointOnShape(angle, radius);
            points.push(point);
          }

          let path = `M ${points[0].x} ${points[0].y}`;
          for (let i = 1; i < points.length; i++) {
            path += ` L ${points[i].x} ${points[i].y}`;
          }
          path += " Z";

          return path;
        }

        // Calculate actual perimeter of the shape
        calculatePerimeter(radius) {
          const segments = 360;
          let perimeter = 0;
          let prevPoint = null;

          for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const point = this.getPointOnShape(angle, radius);

            if (prevPoint) {
              const dx = point.x - prevPoint.x;
              const dy = point.y - prevPoint.y;
              perimeter += Math.sqrt(dx * dx + dy * dy);
            }

            prevPoint = point;
          }

          return perimeter;
        }

        // Calculate radius needed to maintain target perimeter
        static calculatePerimeterConstantRadius(
          cornerRadius,
          targetPerimeter,
          centerX,
          centerY
        ) {
          // Use binary search to find the radius that gives us the target perimeter
          let minRadius = 10;
          let maxRadius = 500;
          const tolerance = 0.1;

          // Create a temporary ring for calculation
          const tempRing = new Ring("temp", "");
          tempRing.centerX = centerX;
          tempRing.centerY = centerY;
          tempRing.cornerRadius = cornerRadius;
          tempRing.innerRadius = 0;

          for (let i = 0; i < 50; i++) {
            const testRadius = (minRadius + maxRadius) / 2;
            tempRing.outerRadius = testRadius;
            const perimeter = tempRing.calculatePerimeter(testRadius);

            if (Math.abs(perimeter - targetPerimeter) < tolerance) {
              return testRadius;
            }

            if (perimeter < targetPerimeter) {
              minRadius = testRadius;
            } else {
              maxRadius = testRadius;
            }
          }

          return (minRadius + maxRadius) / 2;
        }
      }

      // ============================================
      // CONCRETE RING IMPLEMENTATIONS
      // ============================================

      class SeasonsRing extends Ring {
        constructor() {
          super("seasons", "gradient-seasons");
        }

        get sectorCount() {
          return 4;
        }

        getSectorLabel(index) {
          return ["Winter", "Spring", "Summer", "Autumn"][index];
        }
      }

      class MonthsRing extends Ring {
        constructor() {
          super("months", "gradient-months");
          // Gregorian months with actual day counts for 2025 (non-leap year)
          this.gregorianMonths = [
            { name: "Jan", startDay: 0, endDay: 31 }, // 31 days
            { name: "Feb", startDay: 31, endDay: 59 }, // 28 days (2025 is not a leap year)
            { name: "Mar", startDay: 59, endDay: 90 }, // 31 days
            { name: "Apr", startDay: 90, endDay: 120 }, // 30 days
            { name: "May", startDay: 120, endDay: 151 }, // 31 days
            { name: "Jun", startDay: 151, endDay: 181 }, // 30 days
            { name: "Jul", startDay: 181, endDay: 212 }, // 31 days
            { name: "Aug", startDay: 212, endDay: 243 }, // 31 days
            { name: "Sep", startDay: 243, endDay: 273 }, // 30 days
            { name: "Oct", startDay: 273, endDay: 304 }, // 31 days
            { name: "Nov", startDay: 304, endDay: 334 }, // 30 days
            { name: "Dec", startDay: 334, endDay: 365 }, // 31 days
          ];
        }

        get sectorCount() {
          return this.gregorianMonths.length;
        }

        getSectorLabel(index) {
          return this.gregorianMonths[index].name;
        }

        // Override layout to use actual day-based positioning
        layout(
          centerX,
          centerY,
          innerRadius,
          outerRadius,
          cornerRadius,
          direction = 1,
          rotationOffset = 0
        ) {
          this.centerX = centerX;
          this.centerY = centerY;
          this.innerRadius = innerRadius;
          this.outerRadius = outerRadius;
          this.cornerRadius = cornerRadius;
          this.direction = direction; // Store for label drawing

          // Clear previous content
          this.svgGroup.innerHTML = "";

          // Draw sectors based on actual days in year
          const daysInYear = 365;
          // Start at top (12 o'clock) - Jan 1 at the top
          const baseOffset = -Math.PI / 2;
          const rotationRad = (rotationOffset * Math.PI) / 180;
          const angleOffset = baseOffset + rotationRad;

          for (let i = 0; i < this.gregorianMonths.length; i++) {
            const month = this.gregorianMonths[i];
            const progress = (month.startDay / daysInYear) * Math.PI * 2;
            const endProgress = (month.endDay / daysInYear) * Math.PI * 2;

            const startAngle = angleOffset + progress;
            const endAngle = angleOffset + endProgress;
            
            // For CCW, mirror angles around vertical axis: Î¸ â†’ Ï€ - Î¸
            const mirroredStart = this.direction === -1 ? (Math.PI - startAngle) : startAngle;
            const mirroredEnd = this.direction === -1 ? (Math.PI - endAngle) : endAngle;
            
            this.drawSector(i, mirroredStart, mirroredEnd);
          }

          // Draw separator line
          this.drawSeparator();
        }
      }

      class HebrewMonthsRing extends Ring {
        constructor() {
          super("hebrew", "gradient-hebrew");
          // Hebrew months that occur during Gregorian year 2025
          // Calculated using actual Hebrew calendar dates
          this.hebrewMonths = [
            { name: "Tevet", startDay: 0, endDay: 29 }, // Jan 1 - Jan 29 (5785)
            { name: "Shevat", startDay: 29, endDay: 58 }, // Jan 30 - Feb 27 (5785)
            { name: "Adar", startDay: 58, endDay: 88 }, // Feb 28 - Mar 29 (5785)
            { name: "Nisan", startDay: 88, endDay: 117 }, // Mar 30 - Apr 27 (5785)
            { name: "Iyar", startDay: 117, endDay: 147 }, // Apr 28 - May 27 (5785)
            { name: "Sivan", startDay: 147, endDay: 176 }, // May 28 - Jun 25 (5785)
            { name: "Tammuz", startDay: 176, endDay: 206 }, // Jun 26 - Jul 25 (5785)
            { name: "Av", startDay: 206, endDay: 235 }, // Jul 26 - Aug 23 (5785)
            { name: "Elul", startDay: 235, endDay: 265 }, // Aug 24 - Sep 22 (5785)
            { name: "Tishrei", startDay: 265, endDay: 295 }, // Sep 23 - Oct 22 (5786)
            { name: "Cheshvan", startDay: 295, endDay: 324 }, // Oct 23 - Nov 20 (5786)
            { name: "Kislev", startDay: 324, endDay: 354 }, // Nov 21 - Dec 20 (5786)
            { name: "Tevet", startDay: 354, endDay: 365 }, // Dec 21 - Dec 31 (5786)
          ];
        }

        get sectorCount() {
          return this.hebrewMonths.length;
        }

        getSectorLabel(index) {
          return this.hebrewMonths[index].name;
        }

        // Override layout to use actual day-based positioning
        layout(
          centerX,
          centerY,
          innerRadius,
          outerRadius,
          cornerRadius,
          direction = 1,
          rotationOffset = 0
        ) {
          this.centerX = centerX;
          this.centerY = centerY;
          this.innerRadius = innerRadius;
          this.outerRadius = outerRadius;
          this.cornerRadius = cornerRadius;
          this.direction = direction; // Store for label drawing

          // Clear previous content
          this.svgGroup.innerHTML = "";

          // Draw sectors based on actual days in year
          const daysInYear = 365;
          // Start at top (12 o'clock) - Jan 1 at the top
          const baseOffset = -Math.PI / 2;
          const rotationRad = (rotationOffset * Math.PI) / 180;
          const angleOffset = baseOffset + rotationRad;

          for (let i = 0; i < this.hebrewMonths.length; i++) {
            const month = this.hebrewMonths[i];
            const progress = (month.startDay / daysInYear) * Math.PI * 2;
            const endProgress = (month.endDay / daysInYear) * Math.PI * 2;

            const startAngle = angleOffset + progress;
            const endAngle = angleOffset + endProgress;
            
            // For CCW, mirror angles around vertical axis: Î¸ â†’ Ï€ - Î¸
            const mirroredStart = this.direction === -1 ? (Math.PI - startAngle) : startAngle;
            const mirroredEnd = this.direction === -1 ? (Math.PI - endAngle) : endAngle;
            
            this.drawSector(i, mirroredStart, mirroredEnd);
          }

          // Draw separator line
          this.drawSeparator();
        }
      }

      class WeeksRing extends Ring {
        constructor() {
          super("weeks", "gradient-weeks");
        }

        get sectorCount() {
          return 52;
        }

        getSectorLabel(index) {
          // Only label every 4th week to avoid clutter
          return (index + 1) % 4 === 0 ? `W${index + 1}` : "";
        }
      }

      class HolidaysRing extends Ring {
        constructor() {
          super("holidays", "gradient-holidays");
          // Major holidays for 2025 (Hebrew, Christian, European)
          this.holidays = [
            { name: "ðŸŽ† New Year", day: 0 }, // Jan 1
            { name: "ðŸ•¯ï¸ Tu BiShvat", day: 43 }, // Feb 13
            { name: "ðŸ’ Valentine", day: 44 }, // Feb 14
            { name: "ðŸŽ­ Purim", day: 73 }, // Mar 14
            { name: "âœï¸ Palm Sun", day: 103 }, // Apr 13
            { name: "ðŸ· Passover", day: 111 }, // Apr 22
            { name: "âœï¸ Easter", day: 109 }, // Apr 20
            { name: "ðŸ•Šï¸ Yom HaShoah", day: 122 }, // May 2
            { name: "ðŸ‡®ðŸ‡± Yom HaAtzmaut", day: 129 }, // May 9
            { name: "ðŸ‘¨ Father Day", day: 165 }, // Jun 15
            { name: "ðŸ‡ºðŸ‡¸ July 4th", day: 184 }, // Jul 4
            { name: "ðŸ•Šï¸ Tisha B'Av", day: 216 }, // Aug 5
            { name: "ðŸŽ Rosh Hashanah", day: 266 }, // Sep 23-24
            { name: "â˜ªï¸ Yom Kippur", day: 275 }, // Oct 2
            { name: "ðŸ•‹ Sukkot", day: 280 }, // Oct 7
            { name: "ðŸŽƒ Halloween", day: 303 }, // Oct 31
            { name: "ðŸ¦ƒ Thanksgiving", day: 330 }, // Nov 27
            { name: "ðŸ•Ž Hanukkah", day: 338 }, // Dec 5
            { name: "ðŸŽ„ Christmas", day: 358 }, // Dec 25
            { name: "ðŸŽŠ New Year Eve", day: 364 }, // Dec 31
          ];
        }

        get sectorCount() {
          return this.holidays.length;
        }

        getSectorLabel(index) {
          return this.holidays[index].name;
        }

        // Override layout - draw holiday markers at specific days
        layout(
          centerX,
          centerY,
          innerRadius,
          outerRadius,
          cornerRadius,
          direction = 1,
          rotationOffset = 0
        ) {
          this.centerX = centerX;
          this.centerY = centerY;
          this.innerRadius = innerRadius;
          this.outerRadius = outerRadius;
          this.cornerRadius = cornerRadius;
          this.direction = direction; // Store for label drawing

          // Clear previous content
          this.svgGroup.innerHTML = "";

          const daysInYear = 365;
          const baseOffset = -Math.PI / 2;
          const rotationRad = (rotationOffset * Math.PI) / 180;
          const angleOffset = baseOffset + rotationRad;

          // Draw holiday markers (small sectors, Â±1 day)
          for (let i = 0; i < this.holidays.length; i++) {
            const holiday = this.holidays[i];
            const dayProgress = (holiday.day / daysInYear) * Math.PI * 2;
            const dayAngle = angleOffset + dayProgress;

            // Make a small sector (Â±2 days width for visibility)
            const sectorWidth = (3 / daysInYear) * Math.PI * 2;
            const startAngle = dayAngle - sectorWidth / 2;
            const endAngle = dayAngle + sectorWidth / 2;

            // For CCW, mirror angles around vertical axis: Î¸ â†’ Ï€ - Î¸
            const mirroredStart = this.direction === -1 ? (Math.PI - startAngle) : startAngle;
            const mirroredEnd = this.direction === -1 ? (Math.PI - endAngle) : endAngle;

            this.drawSector(i, mirroredStart, mirroredEnd);
          }

          // Draw separator line
          this.drawSeparator();
        }
      }

      // ============================================
      // RING SYSTEM MANAGER
      // ============================================

      class RingSystem {
        constructor(svgContainer, centerX, centerY) {
          this.svgContainer = svgContainer;
          this.centerX = centerX;
          this.centerY = centerY;
          this.rings = [];
          this.ringVisibility = {}; // Track visibility per ring
          this.baseRadius = 250; // Will be adjusted for perimeter preservation
          this.ringWidth = 50; // Increased from 40 for better spacing
          this.ringGap = 5; // Gap between rings
          this.cornerRadius = 0.5;
          this.targetPerimeter = null;
          this.direction = 1; // 1 = CW (clockwise), -1 = CCW (counter-clockwise)
          this.rotationOffset = 0; // Rotation offset in degrees (0, 90, 180, 270)
        }

        addRing(ring, visible = true) {
          ring.render(this.svgContainer);
          this.rings.push(ring);
          this.ringVisibility[ring.name] = visible; // Visible by default unless specified
        }

        setRingVisibility(ringName, visible) {
          this.ringVisibility[ringName] = visible;
          const ring = this.rings.find((r) => r.name === ringName);
          if (ring) {
            ring.svgGroup.style.display = visible ? "block" : "none";
          }
          this.layout();
          this.saveSettings();
        }

        reorderRings(newOrder) {
          // newOrder is array of ring names from outermost to innermost
          const reorderedRings = [];
          for (const name of newOrder) {
            const ring = this.rings.find((r) => r.name === name);
            if (ring) {
              reorderedRings.push(ring);
            }
          }
          this.rings = reorderedRings;
          this.layout();
          this.saveSettings();
        }

        layout() {
          // Calculate base radius to maintain constant perimeter
          if (this.targetPerimeter === null) {
            // First layout - establish target perimeter at cornerRadius = 1 (circle)
            const tempRing = new Ring("temp", "");
            tempRing.centerX = this.centerX;
            tempRing.centerY = this.centerY;
            tempRing.cornerRadius = 1;
            tempRing.outerRadius = this.baseRadius;
            this.targetPerimeter = tempRing.calculatePerimeter(this.baseRadius);
          }

          // Calculate adjusted radius for current corner radius
          const adjustedRadius = Ring.calculatePerimeterConstantRadius(
            this.cornerRadius,
            this.targetPerimeter,
            this.centerX,
            this.centerY
          );

          // Update info panel
          document.getElementById(
            "perimeterInfo"
          ).textContent = `${this.targetPerimeter.toFixed(1)}px`;
          document.getElementById(
            "radiusInfo"
          ).textContent = `${adjustedRadius.toFixed(1)}px`;
          document.getElementById("cornerInfo").textContent = `${(
            this.cornerRadius * 100
          ).toFixed(0)}%`;

          // Layout each ring from outermost to innermost (only visible rings)
          let currentOuterRadius = adjustedRadius;

          for (let i = 0; i < this.rings.length; i++) {
            const ring = this.rings[i];

            if (!this.ringVisibility[ring.name]) {
              continue; // Skip hidden rings
            }

            const innerRadius = currentOuterRadius - this.ringWidth;

            ring.layout(
              this.centerX,
              this.centerY,
              innerRadius,
              currentOuterRadius,
              this.cornerRadius,
              this.direction,
              this.rotationOffset
            );

            // Add gap before next ring
            currentOuterRadius = innerRadius - this.ringGap;
          }

          // Update today indicator
          this.updateTodayIndicator(adjustedRadius);

          // No CSS mirroring needed - mirroring is done mathematically in getPointOnShape
        }

        setRingWidth(width) {
          this.ringWidth = width;
          this.layout();
          this.saveSettings();
        }

        setCornerRadius(radius) {
          this.cornerRadius = radius;
          this.layout();
          this.saveSettings();
        }

        toggleDirection() {
          this.direction = this.direction === 1 ? -1 : 1;
          this.layout();
          this.saveSettings();
          return this.direction;
        }

        rotateYear() {
          this.rotationOffset = (this.rotationOffset + 90) % 360;
          this.layout();
          this.saveSettings();
          return this.rotationOffset;
        }

        getRingOrder() {
          return this.rings.map((r) => r.name);
        }

        getDirection() {
          return this.direction;
        }

        getRotationOffset() {
          return this.rotationOffset;
        }

        updateTodayIndicator(adjustedRadius) {
          // Calculate today's day of year (0-364)
          const now = new Date();
          const startOfYear = new Date(now.getFullYear(), 0, 0);
          const diff = now - startOfYear;
          const oneDay = 1000 * 60 * 60 * 24;
          const dayOfYear = Math.floor(diff / oneDay) - 1; // 0-indexed

          // Calculate angle for today
          const daysInYear = 365;
          const baseOffset = -Math.PI / 2; // Start at top
          const rotationRad = (this.rotationOffset * Math.PI) / 180;
          const progress = (dayOfYear / daysInYear) * Math.PI * 2;
          const angle = baseOffset + rotationRad + progress;
          
          // For CCW, mirror angle around vertical axis: Î¸ â†’ Ï€ - Î¸
          const mirroredAngle = this.direction === -1 ? (Math.PI - angle) : angle;

          // Calculate line end point (just beyond outermost ring)
          const lineLength = adjustedRadius + 15; // Extend 15px beyond
          const endX = this.centerX + lineLength * Math.cos(mirroredAngle);
          const endY = this.centerY + lineLength * Math.sin(mirroredAngle);

          // Update line
          const todayLine = document.getElementById("todayLine");
          if (todayLine) {
            todayLine.setAttribute("x1", this.centerX);
            todayLine.setAttribute("y1", this.centerY);
            todayLine.setAttribute("x2", endX);
            todayLine.setAttribute("y2", endY);
          }

          // Update dot
          const todayDot = document.getElementById("todayDot");
          if (todayDot) {
            todayDot.setAttribute("cx", endX);
            todayDot.setAttribute("cy", endY);
          }
        }

        saveSettings() {
          const settings = {
            cornerRadius: this.cornerRadius,
            ringWidth: this.ringWidth,
            direction: this.direction,
            rotationOffset: this.rotationOffset,
            ringOrder: this.getRingOrder(),
            ringVisibility: this.ringVisibility,
          };
          localStorage.setItem(
            "multiRingCalendarSettings",
            JSON.stringify(settings)
          );
        }

        loadSettings() {
          const saved = localStorage.getItem("multiRingCalendarSettings");
          if (!saved) return false;

          try {
            const settings = JSON.parse(saved);
            this.cornerRadius = settings.cornerRadius || 0.5;
            this.ringWidth = settings.ringWidth || 50;
            this.direction = settings.direction || 1;
            this.rotationOffset = settings.rotationOffset || 0;
            if (settings.ringVisibility) {
              this.ringVisibility = settings.ringVisibility;
            }
            return settings;
          } catch (e) {
            console.error("Failed to load settings:", e);
            return false;
          }
        }
      }

      // ============================================
      // INITIALIZATION
      // ============================================

      const svg = document.getElementById("calendar-svg");
      const container = document.getElementById("rings-container");
      const centerX = 350;
      const centerY = 350;

      // Create ring system
      const ringSystem = new RingSystem(container, centerX, centerY);

      // Ring metadata for layer controls
      const ringMetadata = {
        seasons: { label: "Seasons", color: "#667eea", icon: "ðŸŒ¸" },
        holidays: { label: "Holidays", color: "#fdcb6e", icon: "ðŸŽŠ" },
        months: { label: "Gregorian Months", color: "#f093fb", icon: "ðŸ“…" },
        hebrew: { label: "Hebrew Months", color: "#4facfe", icon: "âœ¡ï¸" },
        weeks: { label: "Weeks", color: "#43e97b", icon: "ðŸ“†" },
      };

      // Load saved settings
      const savedSettings = ringSystem.loadSettings();

      // Add rings (from outermost to innermost)
      const defaultOrder = ["holidays", "weeks", "hebrew", "months", "seasons"];
      const ringOrder =
        savedSettings && savedSettings.ringOrder
          ? savedSettings.ringOrder
          : defaultOrder;

      // Create ring instances
      const ringInstances = {
        holidays: new HolidaysRing(),
        weeks: new WeeksRing(),
        hebrew: new HebrewMonthsRing(),
        months: new MonthsRing(),
        seasons: new SeasonsRing(),
      };

      // Add rings in saved order
      ringOrder.forEach((ringName) => {
        const ring = ringInstances[ringName];
        if (ring) {
          // Get saved visibility or use default
          const defaultVisible = ringName !== "holidays"; // Holidays hidden by default
          const visible =
            savedSettings && savedSettings.ringVisibility
              ? savedSettings.ringVisibility[ringName]
              : defaultVisible;
          ringSystem.addRing(ring, visible);
        }
      });

      // Apply saved settings to UI controls
      if (savedSettings) {
        document.getElementById("cornerRadius").value = Math.round(
          savedSettings.cornerRadius * 100
        );
        document.getElementById("cornerValue").textContent = `${Math.round(
          savedSettings.cornerRadius * 100
        )}%`;
        document.getElementById("ringWidth").value = savedSettings.ringWidth;
        document.getElementById(
          "widthValue"
        ).textContent = `${savedSettings.ringWidth}px`;

        const directionText = savedSettings.direction === 1 ? "CW" : "CCW";
        const directionIcon = savedSettings.direction === 1 ? "â†»" : "â†º";
        document.getElementById(
          "directionToggle"
        ).innerHTML = `${directionIcon} ${directionText}`;
        if (savedSettings.direction === -1) {
          document.getElementById("directionToggle").style.background =
            "rgba(100,200,255,0.3)";
        }
      }

      // Initial layout
      ringSystem.layout();

      // ============================================
      // LAYER CONTROLS
      // ============================================

      const layerList = document.getElementById("layerList");

      const initializeLayerControls = () => {
        const renderLayerControls = () => {
          layerList.innerHTML = "";
          const ringOrder = ringSystem.getRingOrder();

          ringOrder.forEach((ringName, index) => {
            const metadata = ringMetadata[ringName];
            const isVisible = ringSystem.ringVisibility[ringName];

            const li = document.createElement("li");
            li.className = "layer-item";
            li.setAttribute("draggable", "true");
            li.setAttribute("data-ring", ringName);

            li.innerHTML = `
            <span class="drag-handle">â‹®â‹®</span>
            <input 
              type="checkbox" 
              class="layer-checkbox" 
              ${isVisible ? "checked" : ""} 
              data-ring="${ringName}"
            />
            <span class="layer-name">${metadata.icon} ${metadata.label}</span>
            <div class="layer-color" style="background: ${
              metadata.color
            };"></div>
          `;

            layerList.appendChild(li);
          });

          // Add event listeners
          attachLayerEventListeners();
        };

        const attachLayerEventListeners = () => {
          // Checkbox toggles
          document.querySelectorAll(".layer-checkbox").forEach((checkbox) => {
            checkbox.addEventListener("change", (e) => {
              const ringName = e.target.getAttribute("data-ring");
              ringSystem.setRingVisibility(ringName, e.target.checked);
            });
          });

          // Drag and drop
          const items = document.querySelectorAll(".layer-item");
          let draggedItem = null;

          items.forEach((item) => {
            item.addEventListener("dragstart", (e) => {
              draggedItem = item;
              item.classList.add("dragging");
              e.dataTransfer.effectAllowed = "move";
            });

            item.addEventListener("dragend", () => {
              item.classList.remove("dragging");
              draggedItem = null;
            });

            item.addEventListener("dragover", (e) => {
              e.preventDefault();
              if (draggedItem && draggedItem !== item) {
                const rect = item.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (e.clientY < midpoint) {
                  item.classList.add("drag-over");
                } else {
                  item.classList.remove("drag-over");
                }
              }
            });

            item.addEventListener("dragleave", () => {
              item.classList.remove("drag-over");
            });

            item.addEventListener("drop", (e) => {
              e.preventDefault();
              item.classList.remove("drag-over");

              if (draggedItem && draggedItem !== item) {
                const allItems = [...layerList.children];
                const draggedIndex = allItems.indexOf(draggedItem);
                const targetIndex = allItems.indexOf(item);

                if (draggedIndex < targetIndex) {
                  item.after(draggedItem);
                } else {
                  item.before(draggedItem);
                }

                // Update ring system order
                const newOrder = [...layerList.children].map((li) =>
                  li.getAttribute("data-ring")
                );
                ringSystem.reorderRings(newOrder);
              }
            });
          });
        };

        renderLayerControls();
      };

      initializeLayerControls();

      // ============================================
      // CONTROLS
      // ============================================

      const cornerInput = document.getElementById("cornerRadius");
      const widthInput = document.getElementById("ringWidth");
      const cornerValue = document.getElementById("cornerValue");
      const widthValue = document.getElementById("widthValue");
      const directionToggle = document.getElementById("directionToggle");
      const rotateYearBtn = document.getElementById("rotateYear");

      cornerInput.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        cornerValue.textContent = `${value}%`;
        ringSystem.setCornerRadius(value / 100);
      });

      widthInput.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        widthValue.textContent = `${value}px`;
        ringSystem.setRingWidth(value);
      });

      directionToggle.addEventListener("click", () => {
        const newDirection = ringSystem.toggleDirection();
        const directionText = newDirection === 1 ? "CW" : "CCW";
        const directionIcon = newDirection === 1 ? "â†»" : "â†º";
        directionToggle.innerHTML = `${directionIcon} ${directionText}`;
        directionToggle.style.background =
          newDirection === 1
            ? "rgba(255,255,255,0.2)"
            : "rgba(100,200,255,0.3)";
      });

      rotateYearBtn.addEventListener("click", () => {
        const newOffset = ringSystem.rotateYear();
        rotateYearBtn.style.transform = "rotate(90deg)";
        setTimeout(() => {
          rotateYearBtn.style.transform = "";
        }, 200);
      });

      console.log("âœ… Multi-Ring Calendar loaded");
      console.log(
        "ðŸ“Š Rings:",
        ringSystem.rings.map((r) => r.name)
      );
    </script>
  </body>
</html>
